import re

# ================================================================================================================================
# https://docs.python.org/ko/3/howto/regex.html
# 정규표현식에서 대부분의 글자와 문자는 단순히 자신과 일치한다. 예를 들어 정규식 hello는 문자열 hello와 정확히 일치한다.
# 다음은 메타 문자의 전체 목록이다.
# . ^ $ * + ? { } [ ] \ | ( )
# ================================================================================================================================

# 1. [ ]     ▶▶▶ 일치시키려는 문자 집합인 문자 클래스를 지정한다.

p = re.compile(R"[abc]")           # a, b, 또는 c 문자와 일치한다. 이것은 [a-c]와 같다.
print(p.findall("efdsdcae123b"))   # ['c', 'a', 'b']

p = re.compile(R"[a-z]")           # 소문자만 일치
print(p.findall("12345abcdeABCDE"))# ['a', 'b', 'c', 'd', 'e']

p = re.compile(R"[0-2][0-9]")      # 00에서 29까지의 모든 두 자리 숫자와 일치
print(p.findall("53454328493829101828329291")) # ['28', '29', '10', '18', '28', '29', '29']

p = re.compile(R"[0-9A-Fa-f]")     # 한 자리 16진수 숫자와 일치
print(p.findall("402vbhsiACNGIA")) # ['4', '0', '2', 'b', 'A', 'C', 'A']

p = re.compile(R"[\[\](+*).|]")      # [와]를 일치시키려면 \(역슬래쉬)로 이스케이프 처리한다. 그리고 메타 문자는 문자 집합 [ ] 안에서 의미를 상실한다.
print(p.findall("a|(()#$%=+*.*A[]")) # ['|', '(', '(', ')', '+', '*', '.', '*', '[', ']']

p = re.compile(R"[^0-9A-Z]")            # ^는 여집합을 의미한다. 0부터 9까지의 숫자, A부터 Z 까지의 알파벳을 제외한 모든 문자와 일치
print(p.findall("1234567890ABCDEabcd")) # ['a', 'b', 'c', 'd']


# 2. .(dot)           ▶▶▶ 기본적으로 줄바꿈을 제외한 모든 문자와 일치한다. DOTALL 플래그가 지정되면, 개행 문자를 포함한 모든 문자와 일치
p = re.compile(r'.', flags=re.DOTALL)
print(p.findall("afs.;'L#\n\\")) # ['a', 'f', 's', '.', ';', "'", 'L', '#', '\n', '\\']

# 3. ^                ▶▶▶ 문자열의 시작과 일치하고, MULTILINE 모드에서는 각 개행 직후에도 일치한다.
# 리터럴 '^'를 일치시키려면, \^ 로 이스케이프
p = re.compile(r"^Th", flags=re.MULTILINE)
print(p.findall("Therefore\nThere\nThis\nthis\nTHose")) # ['Th', 'Th', 'Th']

# 4. $                ▶▶▶ 문자열의 끝이나 문자열 끝의 줄바꿈 문자 바로 직전과 일치, MULTILINE 모드에서는 개행 문자 앞에서도 일치
# 리터럴 '$'를 일치시키려면, \$ 로 이스케이프
p = re.compile(R'se$', flags=re.MULTILINE)
print(p.findall("revise\nease\ncase\nraise"))  # ['se', 'se', 'se', 'se']

# 5. | (Vertical bar) ▶▶▶ OR 연산자처럼 A와 B가 정규식이면, A|B는 A나 B와 일치하는 문자열과 일치한다.
# '|'로 여러개의 RE를 분리할 수 있다.
# 리터럴 '|'를 일치시키려면, \| 로 이스케이프
p = re.compile(R"hi|HI|Hi|hI")
print(p.findall("HijisuHIJennyhiSerahIOlivia")) # ['Hi', 'HI', 'hi', 'hI']

# 6. *                ▶▶▶ 지정된 RE의 가능한 한 많은 0회 이상의 반복과 일치한다.
p = re.compile(r"en*")
print(p.findall("enable ennnglish ennnnntegral ennnnnnnncourage")) # ['en', 'e', 'ennn', 'ennnnn', 'e', 'ennnnnnnn', 'e']

# 7. +                ▶▶▶ 지정된 RE의 가능한 한 많은 1회 이상의 반복과 일치한다.
p = re.compile(r"[a-zA-Z][0-9]+")
print(p.findall("b32 C0012 A X3243 Y4530218")) # ['b32', 'C0012', 'X3243', 'Y4530218']

# 8. ?                ▶▶▶ 지정된 RE의 0 또는 1반복과 일치한다.
p = re.compile(r"A[0-9]?B")
print(p.findall("AB A89B A1B"))  # ['AB', 'A1B']

# ▶▶▶▶▶ '*', '+', '?' 한정자는 모두 탐욕적(greedy)이다. 그래서 가능한 한 많은 텍스트와 일치하려고 한다.
# 그래서 RE <.*>를 '<a> b <c>'와 일치시키려하면, '<a>'가 아닌 전체 문자열과 일치한다.

# 9. {m}              ▶▶▶ 지정된 RE의 정확히 m 복사가 일치
p = re.compile(r"(hi){3}9+")
print(p.findall("hihi999 hihihi9999 hihihihi99999")) # ['hi', 'hi'] -> hihihi9999, hihihi99999 일치

# 10. {m,n}           ▶▶▶ 지정된 RE의 m에서 n사이의 최대한 많은 반복과 일치
p = re.compile(r"a[0-9]{3,5}")
print(p.findall("a12 a123 a1234 a12345 a123456"))  # ['a123', 'a1234', 'a12345', 'a12345']

# 11. {m,n}?          ▶▶▶ 지정된 RE의 m에서 n사이의 가능한 한 적은 반복과 일치
p = re.compile(r"a[0-9]{3,5}?")
print(p.findall("a12 a123 a1234 a12345 a123456")) # ['a123', 'a123', 'a123', 'a123']

# 12. \(백 슬래쉬)    ▶▶▶ 특수 문자를 이스케이프 하거나('*', '?' 등의 문자를 일치시킬 수 있게 한다.), 특수 시퀀스를 알립니다.

# 13. ( ) 괄호
# ▶▶▶ 괄호 안에 있는 정규식과 일치하며, 그룹의 시작과 끝을 나타낸다. 그룹의 내용은 일치가 수행된 후 조회할 수 있으며,
# 나중에 \number 특수 시퀀스로 일치시킬 수 있다. 리터럴 '('나 ')'를 일치시키려면, \( \)로 이스케이프


# 14. 특수 시퀀스 문자들 
# ======================================================================================================================================
# \number ▶▶▶ 같은 번호의 그룹 내용과 일치한다. 그룹은 1부터 번호가 매겨진다. ex) (.+) \1은 'the the'나  '55 55'와 일치
# \A      ▶▶▶ 문자열의 시작 부분에서만 일치
# \b      ▶▶▶ 빈 문자열과 일치하지만, 단어의 처음이나 끝에만 일치한다. 형식적으로, \b는 \w와 \W 문자 사이의(또는 그 반대), 또는 \w와 문자열 시작/끝 사이의 경게로 정의된다.
# \B      ▶▶▶ 단어의 시작이나 끝에 있지 않을 때만 빈 문자열과 일치한다.(\b의 반대)
# \d      ▶▶▶ 모든 유니코드 십진 숫자와 일치
# \D      ▶▶▶ 십진 숫자가 아닌 모든 문자와 일치(\d의 반대)
# \s      ▶▶▶ 유니코드 공백 문자([ \t\n\r\f\v])와 일치
# \S      ▶▶▶ 공백 문자가 아닌 모든 문자와 일치 (\s의 반대)  -> [^ \t\n\r\f\v]
# \w      ▶▶▶ 유니코드 단어 문자와 일치 ASCII 플래그를 사용하면 [a-zA-Z0-9_]만 일치한다.
# \W      ▶▶▶ 단어 문자가 아닌 모든 문자와 일치 (\w의 반대)  ASCII 플래그를 사용하면 [^a-zA-Z0-9_]와 동등하다
# \Z      ▶▶▶ 문자열의 끝에만 일치
# ======================================================================================================================================


# 15. 컴파일 플래그
# ======================================================================================================================================
# re.ASCII, re.A      ▶▶▶ \w, \b, \s 및 \d와 같은 여러 이스케이프가 해당 속성이 있는 ASCII 문자에만 일치하도록 합니다.
# re.DOTALL, re.S     ▶▶▶ .가 개행 문자를 포함한 모든 문자와 일치하도록 합니다.
# re.IGNORECASE, re.I ▶▶▶ 대소 문자 구분 없는 일치를 수행합니다.
# re.MULTILINE, re.M  ▶▶▶ 다중 행 일치, ^와 $에 영향을 줍니다.
# re.VERBOSE, re.X    ▶▶▶ 더 명확하고 이해하기 쉽게 정리될 수 있는 상세한 RE를 활성화합니다. (예를 들어 주석 허용)
# ======================================================================================================================================


